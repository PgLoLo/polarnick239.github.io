---
layout: ru/blogs/239/2019/post
title:  "Хэш-функция на подстроке"
date:   2019-12-07 00:03:00 +0300
lang:   ru
categories: school239_115_2019_2020
---

Что если хочется в большом тексте быстро за $$O(1)$$ находить хэш-функцию от произвольной подстроки?

Другая хэш-функция
-----

Напоминание - ранее предлагалось использовать этот полиномиальный хэш:

```Опр`````` **Полиномиальный хэш** - функция $$hash(s) = (s[0] + s[1] \cdot p + s[2] * p^2 + s[3] \cdot p^3 + ... + s[n-1] \cdot p^{n-1}) % m$$, где $$s$$ - строка (и соответственно $$s[i]$$ - $$i$$-ый символ - иначе говоря просто число), $$p$$ и $$m$$ - основание и модуль хэширования.

Но в таком случае не выходит пересчитывать хэш подстроки по аналогии с суммой на подмассиве (через суммы на префиксах) - $$hash(s[i...j])=hash(s[i...j]) - hash(s[0...(i-1)])$$ - это не работает!

Давайте попробуем немного изменить полиномиальный хэш - пусть степени простого основания теперь идут в обратном порядке:

```Опр`````` **Полиномиальный хэш (обратный)** - функция $$hash2(s) = (s[0] \cdot p^{n-1} + s[1] \cdot p^{n-2} + s[2] \cdot p^{n-3} + ...  + s[n-3] \cdot p^2 + s[n-2] \cdot p + s[n-1]) % m$$.

В таком случае рассмотрим вспомогательный хэш на префиксе:

$$pref(s, 0) = 0$$

$$pref(s, 1) = (s[0]) % m$$

$$pref(s, 2) = (s[1] \cdot p + s[0]) % m$$

Иначе говоря:

```Опр``` $$pref(s, k) = hash2(s[0...(k-1)])$$ - т.е. хэш-функция на подстроке состоящей из первых $$k$$ символов.

```Свойство``` $$pref(s, k + 1) = (pref(s, k) \cdot p + s[k]) % m$$

```Следствие``` Тогда заметьте что хэш функция подстроки длины $$len$$ начиная с символа $$i$$: $$hash2(s[i...(i+len)]) = (pref(s, i+len) - pref(s, i) \cdot p^{len}) % m$$.

Основные ошибки и советы
-----

1) Если у вас хоть где-то появились отрицательные числа - случилось переполнение целых чисел и все посыпется. Поэтому используйте везде ```long``` вместо ```int``` и берите по модулю после каждой операции.

2) Возводить основание в степень занимает много времени и портит асимптотику, поэтому все нужные вам $$p^{len}$$ надо предподсчитать и сохранить в массив ```long[] pows``` (не забудьте хранить их в ```long``` и брать их по модулю после каждого домножения).

3) Удобно разбить программу на следующие функции: ```static long[] calcPrefixes(String data, int p, int m)``` и ```static long calcHash(long[] pref, long[] pows, int from, int len, int p, int m)```.
Где ```pref``` - преподсчитанные в ```calcPrefixes(...)``` хэш-функции на префиксах, а ```pows``` - преподсчитанные степени основания (см. предыдущий пункт).

4) Для отладки хорошая затея реализовать явную функцию ```static long calcExplicitHash(String data, int from, int len, int p, int m)``` и проверить что ее результат совпадает со всеми вызовами быстрой функцией ```calcHash``` (а в случае не совпадения писать в консоль **FAIL** или кидать ошибку).  

Рекомендуемые источники
-----

[Полиномиальное хэширование + разбор интересных задач](https://codeforces.com/blog/entry/60445) - см. про **Теперь рассмотрим другой вариант выбора функции полиномиального хэширования**.
